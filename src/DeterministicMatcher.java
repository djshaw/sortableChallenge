import java.util.Collection;
import java.util.HashSet;

public class DeterministicMatcher 
    extends Matcher
{
    /**
     * Take a set of matches generated by levenshtein and expand the matches 
     * out to word boundaries.
     */
    protected static Levenshtein.LevenshteinMatch expandMatchToWordBoundary( Levenshtein.LevenshteinMatch match )
    {
	int score = match.GetScore();

	int lhs = match.GetStart();
	for( ; lhs > 0 && match.GetImage().charAt( lhs - 1 ) != ' '; lhs -= 1, score += 1 ) 
	{ }

	int rhs = match.GetEnd();
	for( ; rhs < match.GetImage().length() && match.GetImage().charAt( rhs ) != ' '; rhs += 1, score += 1 )
	{ }

	return new Levenshtein.LevenshteinMatch( match.GetImage(), score, lhs, rhs );
    }

    protected Collection< Levenshtein.LevenshteinMatch > expandMatchesToWordBoundary( Collection< Levenshtein.LevenshteinMatch > matches )
    {
	HashSet< Levenshtein.LevenshteinMatch > results = new HashSet< Levenshtein.LevenshteinMatch >();
	
	for( Levenshtein.LevenshteinMatch match : matches )
	{
	    results.add( expandMatchToWordBoundary( match ) );
	}

	return results;
    }

    public int Match( Product product, Listing listing )
    {
	// The levenshtein matcher is agnostic of sentence structure. At the 
	// very least, we care about words. Thus, after generating substring
	// matches, inflate the matches so they exist on word boundaries.
	Collection< Levenshtein.LevenshteinMatch > manufacturer_matches = 
	    expandMatchesToWordBoundary( Levenshtein.substringMatch( product.GetManufacturer(), listing.GetTitle() ) );

	Collection< Levenshtein.LevenshteinMatch > other_manufacturer_matches = 
	    expandMatchesToWordBoundary( Levenshtein.substringMatch( product.GetManufacturer(), listing.GetManufacturer() ) );

	Collection< Levenshtein.LevenshteinMatch > model_matches = 
	    expandMatchesToWordBoundary( Levenshtein.substringMatch( product.GetModel(), listing.GetTitle() ) );

	Collection< Levenshtein.LevenshteinMatch > family_matches = 
	    expandMatchesToWordBoundary( Levenshtein.substringMatch( product.GetFamily(), listing.GetTitle() ) );

	// Potential improivement: Don't consider something a match if it's
	// a close match for another product. For instance a listing with an 
	// invalid product "WS-11" would match to both valid products "WS-10" 
	// and "WS-110". In this case, we could use cost to determine which 
	// product we should match to.

	int model_score = model_matches.iterator().next().GetScore();

	int lowest_manufacturer_score = manufacturer_matches.iterator().next().GetScore();
	if( other_manufacturer_matches.size() > 0 ) 
	{
	    lowest_manufacturer_score = Math.min( manufacturer_matches.iterator().next().GetScore(),
						  other_manufacturer_matches.iterator().next().GetScore() );
	}

	int family_score = 0;
	if( product.GetFamily() != null && !product.GetFamily().isEmpty() ) {
	    family_score = family_matches.iterator().next().GetScore();
	}
	return model_score
	     + lowest_manufacturer_score
	     + family_score;
    }
}

